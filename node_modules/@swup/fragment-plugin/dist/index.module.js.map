{"version":3,"file":"index.module.js","sources":["../src/inc/env.ts","../src/inc/Logger.ts","../src/inc/functions.ts","../src/inc/ParsedRule.ts","../src/inc/handlers.ts","../src/SwupFragmentPlugin.ts"],"sourcesContent":["declare global {\n\tconst __DEV__: boolean;\n\tconst MICROBUNDLE_TARGET: string;\n\tinterface Window {\n\t\tprocess?: any;\n\t}\n}\n\n/**\n * Make sure process.env is defined in the browser\n */\nif (!window.process) window.process = {};\nif (!window.process.env) window.process.env = {};\n\n/**\n * Export the __DEV__ variable. This will become false in production builds from consumers\n */\nexport const __TEST__ = ['test'].includes(String(process.env.NODE_ENV));\nexport const __DEV__ = ['development', 'test'].includes(String(process.env.NODE_ENV));\n","import { __TEST__ } from './env.js';\n/**\n * Wrap a string in an escape sequence\n * @see https://stackoverflow.com/a/68373080/586823\n */\nconst wrapInEscapeSequence = (s: string, open: number, close: number): string => {\n\tif (s == null) return s;\n\treturn `\\x1b[${open}m${String(s)}\\x1b[${close}m`;\n};\n\n/**\n * Color Codes:\n * @see https://github.com/lzwme/console-log-colors/blob/56a41b352bf9ed327cc864f588b831d92ee6390e/src/index.js\n */\nconst bold = (s: string): string => wrapInEscapeSequence(s, 1, 22);\nconst purple = (s: string): string => wrapInEscapeSequence(s, 94, 39);\n\nconst prepare = (s: string): string => {\n\tif (__TEST__) return s;\n\treturn `ðŸ§© ${bold(s)}`;\n};\n\nexport const highlight = (s: string): string => {\n\tif (__TEST__) return s;\n\treturn purple(s);\n};\n\n/**\n * A slim wrapper around console statements\n */\nexport default class Logger {\n\tlog(...args: any) {\n\t\tconst msg = args.shift();\n\t\tconsole.log(prepare(msg), ...args);\n\t}\n\twarn(...args: any) {\n\t\tconst msg = args.shift();\n\t\tconsole.warn(prepare(msg), ...args);\n\t}\n\terror(...args: any) {\n\t\tconst msg = args.shift();\n\t\tconsole.error(prepare(msg), ...args);\n\t}\n\tlogIf(condition: boolean, ...args: any) {\n\t\tif (condition) this.log(...args);\n\t}\n\twarnIf(condition: boolean, ...args: any) {\n\t\tif (condition) this.warn(...args);\n\t}\n\terrorIf(condition: boolean, ...args: any) {\n\t\tif (condition) this.error(...args);\n\t}\n}\n","import Swup, { Location } from 'swup';\nimport type { Visit, VisitScroll } from 'swup';\nimport type { default as FragmentPlugin } from '../SwupFragmentPlugin.js';\nimport type { Route, Rule, FragmentVisit, FragmentElement } from './defs.js';\nimport type ParsedRule from './ParsedRule.js';\nimport Logger, { highlight } from './Logger.js';\n\nimport { __DEV__ } from './env.js';\n\n/**\n * Handles a page view. Runs on `mount` as well as on every content:replace\n */\nexport const handlePageView = (fragmentPlugin: FragmentPlugin): void => {\n\tprepareFragmentElements(fragmentPlugin);\n\thandleLinksToFragments(fragmentPlugin);\n\tshowDialogs(fragmentPlugin);\n};\n\n/**\n * Run `showModal` for all `<dialog[data-swup-fragment][open]>` elements\n * This puts them on the top layer and makes them ignore css transforms on parent elements\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Top_layer\n */\nfunction showDialogs({ logger }: FragmentPlugin): void {\n\tdocument\n\t\t.querySelectorAll<HTMLDialogElement & FragmentElement>('dialog[data-swup-fragment][open]')\n\t\t.forEach((el) => {\n\t\t\tif (!el.__swupFragment) {\n\t\t\t\tif (__DEV__) logger?.warn(`fragment properties missing on element:`, el);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (el.__swupFragment.modalShown) return;\n\t\t\tel.__swupFragment.modalShown = true;\n\t\t\tel.removeAttribute('open');\n\t\t\t/** don't assume showModal exists â€“ otherwise unit tests will fail */\n\t\t\tel.showModal?.();\n\t\t\tel.addEventListener('keydown', (e) => e.key === 'Escape' && e.preventDefault());\n\t\t});\n}\n\n/**\n * Updates the `href` of links matching [data-swup-link-to-fragment=\"#my-fragment\"]\n */\nfunction handleLinksToFragments({ logger, swup }: FragmentPlugin): void {\n\tconst targetAttribute = 'data-swup-link-to-fragment';\n\tconst links = document.querySelectorAll<HTMLAnchorElement>(`a[${targetAttribute}]`);\n\n\tlinks.forEach((el) => {\n\t\tconst selectors = el.getAttribute(targetAttribute)?.trim();\n\t\tif (!selectors) {\n\t\t\t// prettier-ignore\n\t\t\tif (__DEV__) logger?.warn(`[${targetAttribute}] needs to contain a valid fragment selector`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst fragmentSelectors = parseLinkToFragmentAttribute(selectors);\n\t\tconst fragment = queryFragmentElementSelectorList(fragmentSelectors, swup);\n\n\t\tif (!fragment) {\n\t\t\tif (__DEV__) {\n\t\t\t\tconst verb = fragmentSelectors.length > 1 ? 'are' : 'is';\n\t\t\t\tconst selectorDisplay = highlight(fragmentSelectors.join(', '));\n\n\t\t\t\tlogger?.log(\n\t\t\t\t\t// prettier-ignore\n\t\t\t\t\t`ignoring ${highlight(`[${targetAttribute}=\"${selectors}\"]`)} as ${selectorDisplay} ${verb} missing`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst fragmentUrl = fragment.__swupFragment?.url;\n\t\tif (!fragmentUrl) {\n\t\t\tif (__DEV__) logger?.warn(`no fragment infos found on #${fragment.id}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Help finding suspicious fragment urls\n\t\tif (isEqualUrl(fragmentUrl, swup.getCurrentUrl())) {\n\t\t\t// prettier-ignore\n\t\t\tif (__DEV__) logger?.warn(`The fragment URL of #${fragment.id} is identical to the current URL. This could mean that [data-swup-fragment-url] needs to be provided by the server.`);\n\t\t}\n\n\t\tel.href = fragmentUrl;\n\t});\n}\n\n/**\n * Adds attributes and properties to fragment elements\n */\nfunction prepareFragmentElements({ parsedRules, swup, logger }: FragmentPlugin): void {\n\tconst currentUrl = swup.getCurrentUrl();\n\n\tparsedRules\n\t\t.filter((rule) => rule.matchesFrom(currentUrl) || rule.matchesTo(currentUrl))\n\t\t.forEach((rule) => {\n\t\t\trule.containers.forEach((selector) => {\n\t\t\t\tconst el = queryFragmentElement(`${selector}:not([data-swup-fragment])`, swup);\n\n\t\t\t\t// No element\n\t\t\t\tif (!el) return;\n\n\t\t\t\t// Parse a provided fragment URL\n\t\t\t\tconst providedFragmentUrl = el.getAttribute('data-swup-fragment-url');\n\t\t\t\tif (providedFragmentUrl) {\n\t\t\t\t\tif (__DEV__) {\n\t\t\t\t\t\t// prettier-ignore\n\t\t\t\t\t\tlogger?.log(`fragment url ${highlight(providedFragmentUrl)} for ${highlight(selector)} provided by server`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Get the fragment URL\n\t\t\t\tconst { url } = Location.fromUrl(providedFragmentUrl || currentUrl);\n\n\t\t\t\t// Mark the element as a fragment\n\t\t\t\tel.setAttribute('data-swup-fragment', '');\n\n\t\t\t\t// Augment the element with the necessary properties\n\t\t\t\tel.__swupFragment = { url, selector };\n\t\t\t});\n\t\t});\n}\n\n/**\n * Get all containers that should be replaced for a given visit's route.\n * Ignores containers that already match the current URL, if the visit can't be considered a reload.\n *\n * A visit is being considered a reload, if one of these conditions apply:\n * \t- `route.from` equal to `route.to`\n *  - all containers match the current url and swup is set to navigate on `linkToSelf`\n */\nexport const getFragmentVisitContainers = (\n\troute: Route,\n\tselectors: string[],\n\tswup: Swup,\n\tlogger?: Logger\n): string[] => {\n\tlet fragments: { selector: string; el: FragmentElement }[] = selectors\n\t\t.map((selector) => {\n\t\t\tconst el = document.querySelector<FragmentElement>(selector);\n\n\t\t\tif (!el) {\n\t\t\t\tif (__DEV__) logger?.log(`${highlight(selector)} missing in current document`);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst fragmentElement = queryFragmentElement(selector, swup);\n\n\t\t\tif (!fragmentElement) {\n\t\t\t\tif (__DEV__) {\n\t\t\t\t\t// prettier-ignore\n\t\t\t\t\tlogger?.error(`${highlight(selector)} is outside of swup's default containers`);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tselector,\n\t\t\t\tel\n\t\t\t};\n\t\t})\n\t\t.filter((record): record is { selector: string; el: FragmentElement } => !!record);\n\n\tconst isLinkToSelf = fragments.every((fragment) =>\n\t\telementMatchesFragmentUrl(fragment.el, route.to)\n\t);\n\n\tconst isReload =\n\t\tisEqualUrl(route.from, route.to) ||\n\t\t(isLinkToSelf && swup.options.linkToSelf === 'navigate');\n\n\t/**\n\t * If this is NOT a reload, ignore fragments that already match `route.to`\n\t */\n\tif (!isReload) {\n\t\tfragments = fragments.filter((fragment) => {\n\t\t\tif (elementMatchesFragmentUrl(fragment.el, route.to)) {\n\t\t\t\tif (__DEV__) {\n\t\t\t\t\t// prettier-ignore\n\t\t\t\t\tlogger?.log(`ignoring fragment ${highlight(fragment.selector)} as it already matches the current URL`);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n\n\treturn fragments.map((fragment) => fragment.selector);\n};\n\n/**\n * Checks if an element's fragment url matches a given URL\n */\nexport const elementMatchesFragmentUrl = (el: FragmentElement, url: string): boolean => {\n\tconst fragmentUrl = el.__swupFragment?.url;\n\tif (!fragmentUrl) return false;\n\treturn isEqualUrl(fragmentUrl, url);\n};\n\n/**\n * Checks if two URLs should be considered equal:\n *\n * - ignores trailing slashes\n * - ignores query string order\n *\n * Example: /test?foo=bar&baz=boo === /test/?baz=boo&foo=bar\n */\nconst isEqualUrl = (url1: string, url2: string) => {\n\treturn normalizeUrl(url1) === normalizeUrl(url2);\n};\n\n/**\n * Normalize a URL\n *\n * - removes the trailing slash\n * - sorts query params\n */\nexport const normalizeUrl = (url: string) => {\n\tif (!url.trim()) return url;\n\n\tconst removeTrailingSlash = (str: string) => str.replace(/\\/+$/g, '');\n\n\tconst location = Location.fromUrl(url);\n\tlocation.searchParams.sort();\n\n\treturn removeTrailingSlash(location.pathname) + location.search;\n};\n\n/**\n * Removes all fragment traces from all fragment elements\n */\nexport const cleanupFragmentElements = () => {\n\tdocument.querySelectorAll<FragmentElement>('[data-swup-fragment]').forEach((el) => {\n\t\tel.removeAttribute('data-swup-fragment-url');\n\t\tdelete el.__swupFragment;\n\t});\n};\n\n/**\n * Get the route from a given visit\n */\nexport const getRoute = (visit: Visit): Route | undefined => {\n\tconst from = visit.from.url;\n\tconst to = visit.to.url;\n\tif (!from || !to) return;\n\treturn { from, to };\n};\n\n/**\n * Adds or removes a rule's name class from all current fragment elements\n */\nexport const toggleFragmentVisitClass = (\n\tfragmentVisit: FragmentVisit | undefined,\n\ttoggle: boolean\n): void => {\n\tif (!fragmentVisit?.name) return;\n\n\tconst { name, containers } = fragmentVisit;\n\n\tcontainers.forEach((selector) => {\n\t\tdocument.querySelector(selector)?.classList.toggle(`to-${name}`, toggle);\n\t});\n};\n\n/**\n * Get the first matching rule for a given route\n */\nexport const getFirstMatchingRule = (\n\troute: Route,\n\trules: ParsedRule[],\n\tvisit: Visit\n): ParsedRule | undefined => {\n\treturn rules.find((rule) => rule.matches(route, visit));\n};\n\n/**\n * Makes sure unchanged fragment elements land in the cache of the current page\n */\nexport const cacheForeignFragmentElements = ({ swup, logger }: FragmentPlugin): void => {\n\tconst currentUrl = swup.getCurrentUrl();\n\tconst cache = swup.cache;\n\n\t// Get the cache entry for the current URL\n\tconst currentCache = cache.get(currentUrl);\n\tif (!currentCache) return;\n\tconst currentCachedDocument = new DOMParser().parseFromString(currentCache.html, 'text/html');\n\n\t// debug info\n\tconst updatedFragments: FragmentElement[] = [];\n\n\t/**\n\t * We only want to handle fragment elements that\n\t *  - are not templates\n\t *  - don't fit the current URL\n\t */\n\tconst foreignFragmentElements = Array.from(\n\t\tdocument.querySelectorAll<FragmentElement>('[data-swup-fragment]')\n\t).filter((el) => {\n\t\tif (el.matches('template')) return false;\n\t\tif (elementMatchesFragmentUrl(el, currentUrl)) return false;\n\t\treturn true;\n\t});\n\n\t// Bail early if there are no foreign fragment elements\n\tif (!foreignFragmentElements.length) return;\n\n\tif (!swup.options.cache) {\n\t\tif (__DEV__) logger?.warn(`can't cache foreign fragment elements without swup's cache`);\n\t\treturn;\n\t}\n\n\tforeignFragmentElements.forEach((el) => {\n\t\t// Don't cache the fragment if it contains fragment elements\n\t\tconst containsFragments = el.querySelector('[data-swup-fragment]') != null;\n\t\tif (containsFragments) return;\n\n\t\tconst fragmentUrl = el.__swupFragment?.url;\n\t\tif (!fragmentUrl) {\n\t\t\tif (__DEV__) logger?.warn(`no fragment url found:`, el);\n\t\t\treturn;\n\t\t}\n\n\t\tconst fragmentSelector = el.__swupFragment?.selector;\n\t\tif (!fragmentSelector) {\n\t\t\tif (__DEV__) logger?.warn(`no fragment selector found:`, el);\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the cache entry for the fragment URL, bail early if it doesn't exist\n\t\tconst fragmentCache = cache.get(fragmentUrl);\n\t\tif (!fragmentCache) return;\n\n\t\t// Check if the fragment exists in the current cached document\n\t\tconst currentFragment = currentCachedDocument.querySelector(fragmentSelector);\n\t\tif (!currentFragment) return;\n\n\t\t// Get a fresh copy of the fragment from it's original cache\n\t\tconst unchangedFragment = new DOMParser()\n\t\t\t.parseFromString(fragmentCache.html, 'text/html')\n\t\t\t.querySelector(fragmentSelector);\n\t\tif (!unchangedFragment) return;\n\n\t\t// Make sure the dynamic fragment url makes it to the cache\n\t\tunchangedFragment.setAttribute('data-swup-fragment-url', fragmentUrl);\n\n\t\t// Replace the current fragment with the unchanged fragment\n\t\tcurrentFragment.replaceWith(unchangedFragment);\n\n\t\t// For debugging\n\t\tupdatedFragments.push(el);\n\t});\n\n\tif (!updatedFragments.length) return;\n\n\t// Update the cache of the current page with the updated html\n\tcache.update(currentUrl, {\n\t\tfragmentHtml: currentCachedDocument.documentElement.outerHTML\n\t});\n\n\tupdatedFragments.forEach((el) => {\n\t\tconst url = el.__swupFragment?.url || '';\n\t\tconst selector = el.__swupFragment?.selector || '';\n\t\t// prettier-ignore\n\t\tif (__DEV__) logger?.log(`updated cache with ${highlight(selector)} from ${highlight(url)}`);\n\t});\n};\n\n/**\n * Skips the animation if all current containers are <template> elements\n */\nexport function shouldSkipAnimation(fragmentVisit?: FragmentVisit): boolean {\n\tif (!fragmentVisit) return false;\n\n\treturn fragmentVisit.containers.every((selector) => {\n\t\treturn (\n\t\t\tdocument.querySelector<FragmentElement>(selector)?.tagName?.toLowerCase() === 'template'\n\t\t);\n\t});\n}\n\n/**\n * Remove duplicates from an array\n */\nexport function dedupe<T>(arr: Array<T>): Array<T> {\n\treturn [...new Set<T>(arr)];\n}\n\n/**\n * Adjusts visit.scroll based on given fragment visit\n */\nexport function adjustVisitScroll(fragmentVisit: FragmentVisit, scroll: VisitScroll): VisitScroll {\n\tif (typeof fragmentVisit.scroll === 'boolean') {\n\t\treturn { ...scroll, reset: fragmentVisit.scroll };\n\t}\n\tif (typeof fragmentVisit.scroll === 'string' && !scroll.target) {\n\t\treturn { ...scroll, target: fragmentVisit.scroll };\n\t}\n\treturn scroll;\n}\n\n/**\n * Queries a list of fragment element selectors via `queryFragmentElement`\u001b and returns the first match. *\n *\n */\nexport function queryFragmentElementSelectorList(\n\tfragmentSelectors: Array<string>,\n\tswup: Swup\n): FragmentElement | undefined {\n\tconst selectors = fragmentSelectors.map((sel) => sel.trim());\n\n\tfor (const selector of selectors) {\n\t\tconst fragment = queryFragmentElement(selector, swup);\n\t\tif (fragment) return fragment;\n\t}\n\n\treturn;\n}\n\n/**\n * Queries a fragment element. Needs to be either:\n *\n * - one of swup's default containers\n * - inside of one of swup's default containers\n */\nexport function queryFragmentElement(\n\tfragmentSelector: string,\n\tswup: Swup\n): FragmentElement | undefined {\n\tfor (const containerSelector of swup.options.containers) {\n\t\tconst container = document.querySelector(containerSelector);\n\t\tif (container?.matches(fragmentSelector)) return container as FragmentElement;\n\n\t\tconst fragment = container?.querySelector<FragmentElement>(fragmentSelector);\n\t\tif (fragment) return fragment;\n\t}\n\treturn;\n}\n\n/**\n * Clone fragment rules (replacement for `structuredClone`)\n */\nexport function cloneRules(rules: Rule[]): Rule[] {\n\tif (!Array.isArray(rules)) throw new Error(`cloneRules() expects an array of rules`);\n\n\treturn rules.map((rule) => ({\n\t\t...rule,\n\t\tfrom: Array.isArray(rule.from) ? [...rule.from] : rule.from,\n\t\tto: Array.isArray(rule.to) ? [...rule.to] : rule.to,\n\t\tcontainers: [...rule.containers]\n\t}));\n}\n\n/**\n * Parses a fragment link attribute value into an array of fragment selectors\n */\nexport function parseLinkToFragmentAttribute(value: string): string[] {\n\tconst fragmentSelectors = value\n\t\t.trim()\n\t\t.split(',')\n\t\t.map((sel) => sel.trim());\n\n\treturn fragmentSelectors;\n}\n\n/**\n * Create a visit object for tests\n */\nexport function stubVisit(options: { from?: string; to: string }) {\n\tconst swup = new Swup();\n\t// @ts-expect-error swup.createVisit is protected\n\treturn swup.createVisit(options);\n}\n","import { matchPath, classify, Location } from 'swup';\nimport type { Swup, Path, Visit } from 'swup';\nimport type { Route, Rule, Predicate } from './defs.js';\nimport { dedupe, queryFragmentElement } from './functions.js';\nimport Logger, { highlight } from './Logger.js';\nimport { __DEV__ } from './env.js';\n\ntype Options = Rule & {\n\tswup: Swup;\n\tlogger?: Logger;\n};\n\n/**\n * Represents a Rule\n */\nexport default class ParsedRule {\n\treadonly matchesFrom: ReturnType<typeof matchPath>;\n\treadonly matchesTo: ReturnType<typeof matchPath>;\n\n\tswup: Swup;\n\tfrom: Path;\n\tto: Path;\n\tcontainers: string[];\n\tname?: string;\n\tscroll: boolean | string = false;\n\tfocus?: boolean | string;\n\tlogger?: Logger;\n\tif: Predicate = () => true;\n\n\tconstructor(options: Options) {\n\t\tthis.swup = options.swup;\n\t\tthis.logger = options.logger;\n\t\tthis.from = options.from || '';\n\t\tthis.to = options.to || '';\n\n\t\tif (options.name) this.name = classify(options.name);\n\t\tif (typeof options.scroll !== 'undefined') this.scroll = options.scroll;\n\t\tif (typeof options.focus !== 'undefined') this.focus = options.focus;\n\t\tif (typeof options.if === 'function') this.if = options.if;\n\n\t\tthis.containers = this.parseContainers(options.containers);\n\n\t\tif (__DEV__) {\n\t\t\tthis.logger?.errorIf(!this.to, `Every fragment rule must contain a 'to' path`, this);\n\t\t\tthis.logger?.errorIf(!this.from, `Every fragment rule must contain a 'from' path`, this); // prettier-ignore\n\t\t}\n\n\t\tthis.matchesFrom = matchPath(this.from);\n\t\tthis.matchesTo = matchPath(this.to);\n\t}\n\n\t/**\n\t * Parse provided fragment containers\n\t */\n\tparseContainers(rawContainers: string[]): string[] {\n\t\tif (!Array.isArray(rawContainers) || !rawContainers.length) {\n\t\t\t// prettier-ignore\n\t\t\tif (__DEV__) this.logger?.error(`Every fragment rule must contain an array of containers`, this.getDebugInfo());\n\t\t\treturn [];\n\t\t}\n\t\t// trim selectors\n\t\tconst containers = dedupe(rawContainers.map((selector) => selector.trim()));\n\t\treturn containers.filter((selector) => {\n\t\t\tconst result = this.validateSelector(selector);\n\t\t\tthis.logger?.errorIf(result instanceof Error, result);\n\t\t\treturn result === true;\n\t\t});\n\t}\n\n\t/**\n\t * Validate a fragment selector\n\t *\n\t * - only IDs are allowed\n\t * - no nested selectors\n\t */\n\tvalidateSelector(selector: string): true | Error {\n\t\tif (!selector.startsWith('#')) {\n\t\t\treturn new Error(`fragment selectors must be IDs: ${selector}`);\n\t\t}\n\n\t\tif (selector.match(/\\s|>/)) {\n\t\t\treturn new Error(`fragment selectors must not be nested: ${selector}`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get debug info for logging\n\t */\n\tgetDebugInfo() {\n\t\tconst { from, to, containers } = this;\n\t\treturn {\n\t\t\tfrom: String(from),\n\t\t\tto: String(to),\n\t\t\tcontainers: String(containers)\n\t\t};\n\t}\n\n\t/**\n\t * Checks if a given route matches this rule\n\t */\n\tpublic matches(route: Route, visit: Visit): boolean {\n\t\tif (!this.if(visit)) {\n\t\t\tif (__DEV__) {\n\t\t\t\tthis.logger?.log(`ignoring fragment rule due to custom rule.if:`, this);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { url: fromUrl } = Location.fromUrl(route.from);\n\t\tconst { url: toUrl } = Location.fromUrl(route.to);\n\n\t\tconst matchesRoute = !!this.matchesFrom(fromUrl) && !!this.matchesTo(toUrl);\n\t\tif (!matchesRoute) return false;\n\n\t\tfor (const selector of this.containers) {\n\t\t\tconst result = this.validateFragmentSelectorForMatch(selector);\n\t\t\tif (result instanceof Error) {\n\t\t\t\tif (__DEV__) this.logger?.error(result, this.getDebugInfo());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Validates a fragment element at runtime when this rule's route matches\n\t */\n\tvalidateFragmentSelectorForMatch(selector: string): true | Error {\n\t\tif (!document.querySelector(selector)) {\n\t\t\t// prettier-ignore\n\t\t\treturn new Error(`skipping rule since ${highlight(selector)} doesn't exist in the current document`);\n\t\t}\n\t\tif (!queryFragmentElement(selector, this.swup)) {\n\t\t\t// prettier-ignore\n\t\t\treturn new Error(`skipping rule since ${highlight(selector)} is outside of swup's default containers`);\n\t\t}\n\t\treturn true;\n\t}\n}\n","import type { Handler } from 'swup';\nimport { highlight } from './Logger.js';\nimport type { default as FragmentPlugin } from '../SwupFragmentPlugin.js';\n\nimport {\n\thandlePageView,\n\tgetRoute,\n\ttoggleFragmentVisitClass,\n\tgetFirstMatchingRule,\n\tcacheForeignFragmentElements,\n\tshouldSkipAnimation,\n\tadjustVisitScroll\n} from './functions.js';\n\nimport { __DEV__ } from './env.js';\n\n/**\n * Do not scroll if clicking on a link to the same page\n * and the route matches a fragment rule\n */\nexport const onLinkToSelf: Handler<'link:self'> = function (this: FragmentPlugin, visit) {\n\tconst route = getRoute(visit);\n\tif (!route) return;\n\n\tconst rule = getFirstMatchingRule(route, this.parsedRules, visit);\n\n\tif (rule) visit.scroll.reset = false;\n};\n\n/**\n * Prepare fragment visits\n */\nexport const onVisitStart: Handler<'visit:start'> = async function (this: FragmentPlugin, visit) {\n\tconst route = getRoute(visit);\n\tif (!route) return;\n\n\tconst fragmentVisit = this.getFragmentVisit(route, visit);\n\n\t/**\n\t * Bail early if the current route doesn't match\n\t * a rule or wouldn't replace any fragment elements\n\t */\n\tif (!fragmentVisit) return;\n\n\tvisit.fragmentVisit = fragmentVisit;\n\n\tif (__DEV__) {\n\t\tthis.logger?.log(`fragment visit: ${highlight(visit.fragmentVisit.containers.join(', '))}`);\n\t}\n\n\tvisit.scroll = adjustVisitScroll(fragmentVisit, visit.scroll);\n\n\t// Fragment Plugin can't know if Accesssibilty Plugin is installed\n\t// @ts-expect-error\n\tconst a11y = visit.a11y as { focus?: boolean | string };\n\tif (typeof fragmentVisit.focus !== 'undefined') {\n\t\tif (__DEV__) {\n\t\t\tthis.logger?.errorIf(\n\t\t\t\t!a11y,\n\t\t\t\t\"Can't set visit.a11y.focus. Is @swup/a11y-plugin installed?\"\n\t\t\t);\n\t\t}\n\t\tif (a11y) a11y.focus = fragmentVisit.focus;\n\t}\n\n\t// Add the transition classes directly to the containers for this visit\n\tvisit.animation.scope = visit.fragmentVisit.containers;\n\n\t// Overwrite the containers for this visit\n\tvisit.containers = visit.fragmentVisit.containers;\n\n\t// Overwrite the animationSelector for this visit\n\tvisit.animation.selector = visit.fragmentVisit.containers.join(',');\n\n\ttoggleFragmentVisitClass(fragmentVisit, true);\n};\n\n/**\n * Skips the out-animation for <template> fragment elements\n */\nexport const maybeSkipOutAnimation: Handler<'animation:out:await'> = function (\n\tthis: FragmentPlugin,\n\tvisit,\n\targs\n) {\n\tif (visit.fragmentVisit && shouldSkipAnimation(visit.fragmentVisit)) {\n\t\tif (__DEV__)\n\t\t\tthis.logger?.log(\n\t\t\t\t`${highlight('out')}-animation skipped for ${highlight(\n\t\t\t\t\tvisit.fragmentVisit?.containers.toString()\n\t\t\t\t)}`\n\t\t\t);\n\t\targs.skip = true;\n\t}\n};\n\n/**\n * Skips the in-animation for <template> fragment elements\n */\nexport const maybeSkipInAnimation: Handler<'animation:in:await'> = function (\n\tthis: FragmentPlugin,\n\tvisit,\n\targs\n) {\n\tif (visit.fragmentVisit && shouldSkipAnimation(visit.fragmentVisit)) {\n\t\tif (__DEV__)\n\t\t\tthis.logger?.log(\n\t\t\t\t`${highlight('in')}-animation skipped for ${highlight(\n\t\t\t\t\tvisit.fragmentVisit?.containers.toString()\n\t\t\t\t)}`\n\t\t\t);\n\t\targs.skip = true;\n\t}\n};\n\n/**\n * Runs directly before replacing the content\n */\nexport const beforeContentReplace: Handler<'content:replace'> = function (\n\tthis: FragmentPlugin,\n\tvisit,\n\targs\n) {\n\t/**\n\t * Only use the fragment cache if navigating without a trigger (e.g. link click)\n\t * (PopStateEvent, swup.navigate)\n\t */\n\tif (visit.trigger.el || !visit.to.url) return;\n\n\tconst cache = this.swup.cache.get(visit.to.url);\n\tif (!cache || !cache.fragmentHtml) return;\n\n\tvisit.to.document = new DOMParser().parseFromString(cache.fragmentHtml, 'text/html');\n\tvisit.to.html = cache.fragmentHtml;\n\n\tif (__DEV__) this.logger?.log(`fragment cache used for ${highlight(visit.to.url!)}`);\n};\n\n/**\n * Runs after the content was replaced\n */\nexport const onContentReplace: Handler<'content:replace'> = function (this: FragmentPlugin, visit) {\n\ttoggleFragmentVisitClass(visit.fragmentVisit, true);\n\thandlePageView(this);\n\tcacheForeignFragmentElements(this);\n};\n\n/**\n * Remove possible fragment rule names from fragment elements\n */\nexport const onVisitEnd: Handler<'visit:end'> = function (this: FragmentPlugin, visit) {\n\ttoggleFragmentVisitClass(visit.fragmentVisit, false);\n};\n","import PluginBase from '@swup/plugin';\nimport ParsedRule from './inc/ParsedRule.js';\nimport Logger from './inc/Logger.js';\nimport {\n\thandlePageView,\n\tcleanupFragmentElements,\n\tgetFirstMatchingRule,\n\tgetFragmentVisitContainers,\n\tcloneRules\n} from './inc/functions.js';\nimport type { Options, Rule, Route, FragmentVisit } from './inc/defs.js';\nimport * as handlers from './inc/handlers.js';\nimport { __DEV__ } from './inc/env.js';\nimport type { Visit } from 'swup';\n\ntype RequireKeys<T, K extends keyof T> = Partial<T> & Pick<T, K>;\ntype InitOptions = RequireKeys<Options, 'rules'>;\n\n/**\n * The main plugin class\n */\nexport default class SwupFragmentPlugin extends PluginBase {\n\treadonly name = 'SwupFragmentPlugin';\n\treadonly requires = { swup: '>=4.6' };\n\n\tprotected _rawRules: Rule[] = [];\n\tprotected _parsedRules: ParsedRule[] = [];\n\n\tget parsedRules() {\n\t\treturn this._parsedRules;\n\t}\n\n\toptions: Options;\n\n\tprotected defaults: Options = {\n\t\trules: [],\n\t\tdebug: false\n\t};\n\n\tlogger?: Logger;\n\n\t/**\n\t * Plugin Constructor\n\t * The options are NOT optional and need to contain at least a `rules` property\n\t */\n\tconstructor(options: InitOptions) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\t/**\n\t * Runs when the plugin is being mounted\n\t */\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tthis.setRules(this.options.rules);\n\t\tif (__DEV__) {\n\t\t\tif (this.options.debug) this.logger = new Logger();\n\t\t}\n\n\t\tthis.before('link:self', handlers.onLinkToSelf);\n\t\tthis.on('visit:start', handlers.onVisitStart);\n\t\tthis.before('animation:out:await', handlers.maybeSkipOutAnimation);\n\t\tthis.before('animation:in:await', handlers.maybeSkipInAnimation);\n\t\tthis.before('content:replace', handlers.beforeContentReplace);\n\t\tthis.on('content:replace', handlers.onContentReplace);\n\t\tthis.on('visit:end', handlers.onVisitEnd);\n\n\t\tif (__DEV__) {\n\t\t\tthis.logger?.warnIf(\n\t\t\t\t!swup.options.cache,\n\t\t\t\t`fragment caching will only work with swup's cache being active`\n\t\t\t);\n\t\t}\n\n\t\thandlePageView(this);\n\t}\n\n\t/**\n\t * Runs when the plugin is being unmounted\n\t */\n\tunmount() {\n\t\tsuper.unmount();\n\t\tcleanupFragmentElements();\n\t}\n\n\t/**\n\t * Set completely new rules\n\t *\n\t * @access public\n\t */\n\tsetRules(rules: Rule[]) {\n\t\tthis._rawRules = cloneRules(rules);\n\t\tthis._parsedRules = rules.map((rule) => this.parseRule(rule));\n\t\tif (__DEV__) this.logger?.log('Updated fragment rules', this.getRules());\n\t}\n\n\t/**\n\t * Get a clone of the current rules\n\t *\n\t * @access public\n\t */\n\tgetRules() {\n\t\treturn cloneRules(this._rawRules);\n\t}\n\n\t/**\n\t * Prepend a rule to the existing rules\n\t *\n\t * @access public\n\t */\n\tprependRule(rule: Rule) {\n\t\tthis.setRules([rule, ...this.getRules()]);\n\t}\n\n\t/**\n\t * Append a rule to the existing rules\n\t *\n\t * @access public\n\t */\n\tappendRule(rule: Rule) {\n\t\tthis.setRules([...this.getRules(), rule]);\n\t}\n\n\t/**\n\t * Parse a rule (for e.g. debugging)\n\t *\n\t * @access public\n\t */\n\tparseRule(rule: Rule): ParsedRule {\n\t\treturn new ParsedRule({\n\t\t\t...rule,\n\t\t\tlogger: this.logger,\n\t\t\tswup: this.swup\n\t\t});\n\t}\n\n\t/**\n\t * Get the fragment visit object for a given route\n\t *\n\t * @access public\n\t */\n\tgetFragmentVisit(route: Route, visit?: Visit): FragmentVisit | undefined {\n\t\tconst rule = getFirstMatchingRule(\n\t\t\troute,\n\t\t\tthis.parsedRules,\n\t\t\t// @ts-expect-error createVisit is protected\n\t\t\tvisit || this.swup.createVisit(route)\n\t\t);\n\n\t\t// Bail early if no rule matched\n\t\tif (!rule) return;\n\n\t\t// Get containers that should be replaced for this visit\n\t\tconst containers = getFragmentVisitContainers(\n\t\t\troute,\n\t\t\trule.containers,\n\t\t\tthis.swup,\n\t\t\tthis.logger\n\t\t);\n\n\t\t/** Bail early if there are no fragment elements found for this visit */\n\t\tif (!containers.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Pick properties from the current rule that should be projected into the fragmentVisit object\n\t\tconst { name, scroll, focus } = rule;\n\n\t\tconst fragmentVisit: FragmentVisit = {\n\t\t\tcontainers,\n\t\t\tname,\n\t\t\tscroll,\n\t\t\tfocus\n\t\t};\n\n\t\treturn fragmentVisit;\n\t}\n}\n"],"names":["window","process","env","__TEST__","includes","String","NODE_ENV","__DEV__","wrapInEscapeSequence","s","open","close","prepare","bold","highlight","purple","Logger","log","args","slice","call","arguments","msg","shift","console","warn","error","logIf","condition","this","warnIf","errorIf","handlePageView","fragmentPlugin","parsedRules","swup","logger","currentUrl","getCurrentUrl","filter","rule","matchesFrom","matchesTo","forEach","containers","selector","el","queryFragmentElement","providedFragmentUrl","getAttribute","url","Location","fromUrl","setAttribute","__swupFragment","prepareFragmentElements","targetAttribute","document","querySelectorAll","selectors","trim","fragmentSelectors","split","map","sel","fragment","queryFragmentElementSelectorList","verb","length","selectorDisplay","join","fragmentUrl","isEqualUrl","id","href","handleLinksToFragments","modalShown","removeAttribute","showModal","addEventListener","e","key","preventDefault","showDialogs","elementMatchesFragmentUrl","url1","url2","normalizeUrl","location","searchParams","sort","pathname","replace","search","getRoute","visit","from","to","toggleFragmentVisitClass","fragmentVisit","toggle","name","querySelector","classList","getFirstMatchingRule","route","rules","find","matches","shouldSkipAnimation","every","tagName","toLowerCase","fragmentSelector","containerSelector","options","container","cloneRules","Array","isArray","Error","ParsedRule","constructor","scroll","focus","if","classify","parseContainers","matchPath","rawContainers","arr","Set","result","validateSelector","getDebugInfo","startsWith","match","toUrl","validateFragmentSelectorForMatch","onLinkToSelf","reset","onVisitStart","_this","Promise","resolve","getFragmentVisit","target","adjustVisitScroll","a11y","animation","scope","reject","maybeSkipOutAnimation","toString","skip","maybeSkipInAnimation","beforeContentReplace","trigger","cache","get","fragmentHtml","DOMParser","parseFromString","html","onContentReplace","cacheForeignFragmentElements","currentCache","currentCachedDocument","updatedFragments","foreignFragmentElements","fragmentCache","currentFragment","unchangedFragment","replaceWith","push","update","documentElement","outerHTML","onVisitEnd","SwupFragmentPlugin","PluginBase","_parsedRules","super","requires","_rawRules","defaults","debug","mount","setRules","before","handlers","on","unmount","parseRule","getRules","prependRule","appendRule","createVisit","getFragmentVisitContainers","fragments","record","isLinkToSelf","linkToSelf"],"mappings":"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"}